<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2026 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Jason Jiang, Jude Lifset</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-jasonjiang200/">https://cal-cs184-student.github.io/hw-webpages-jasonjiang200/</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw1-rasterizer-imperial-jade">https://github.com/cal-cs184-student/hw1-rasterizer-imperial-jade</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		First, we calculate the bounding box of the triangle. This means calculating the minimum and maximum x and y coordinate that appear among all 3 vertices. 
		Next, we calculate the winding order of the vertices. This is done by calculating two vectors representing edges (AB and AC) of the triangle. With a clockwise winding order, the cross product will have a negative z-component and vice versa.
		Finally, we iterate over each pixel that is within the bounding box of the rectangle. We sample the center of each pixel and consider the vector from each vertex to the pixel center. We take 3 cross products with 3 vectors representing the edges, each time checking the sign to see if the pixel center lies in the correct half plane to be within the triangle. Again, we use the sign of the z component to do this. If the pixel center is in all 3 half planes, we fill it in since it is inside the triangle.
		
		<figure>
			<img src="screenshot_2-8_20-18-40.png" alt="task1pic" style="width:50%"/>
			<figcaption>Rasterized triangles with disconnected section highlighted for skinny triangle.</figcaption>
		</figure>
			

		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		In order to support supersampling, the sample buffer is sized up to be n times larger, where n is the sample rate. In the triangle rasterizing function, we now sample each pixel additional times For example, with 3x3 supersampling, we'd sample the pixel 1/6, 3/6, and 5/6 of the way across and down.
		The fill_pixel function needed to be updated in order to support having a sample rate. This makes sure that the correct sub-pixel is filled in.
		The rasterize point function was updated to fill all subpixels with the same color, so that nothing would be lost after averaging.
		Superampling ends up being useful because it acts like a low pass filter, blurring the image and attenuating higher frequencies to get rid of aliasing. As we see below, it can help get rid of disconnected portions in a triangle.
		We can see that as the sampling rate goes up, the triangle's sharp corner looks better and better.
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="screenshot_2-8_20-18-40.png" width="400px"/>
				  <figcaption>1x1 sampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-11_11-29-58.png" width="400px"/>
				  <figcaption>2x2 supersampling.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="screenshot_2-11_11-30-6.png" width="400px"/>
				  <figcaption>3x3 supersampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-11_11-30-24.png" width="400px"/>
				  <figcaption>4x4 supersamplings.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<h2>Task 3: Transforms</h2>
		We changed our robot to be doing a jig. We used the hierarchical transform to bend the robot's knee, and we also gave the robot a face and colored it green. 
		<figure>
			<img src="screenshot_2-10_17-3-15.png" alt="vro" style="width:50%"/>
			<figcaption>Our robot with a face and green color.</figcaption>
		</figure>
			
		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates is a coordinate system for a triangle that allows us to express any point in the triangle as a weighted average of the vertices. Each coordinate is the weight of one point in the triangle and the three coordinates sum to 1 when normalized.
		The image below represents this coordinate system. Each vertex of the triangle is a different color (red, white and black) and the color of each point in the triangle is a weighted average of the colors of the vertices. The closer a point is to a vertex, the more weight that vertex has in determining the color of that point. The points near the red vertex are more red, points near the white vertex are more white, and points near the black vertex are more black. 
		Points in the middle of the triangle are a blend of all three colors.

		<figure>
			<img src="screenshot_2-10_17-45-10.png" alt="triangle" style="width:50%"/>
			<figcaption>Barycentric coordinates in a triangle with red, white, and black vertices.</figcaption>
		</figure>

		<figure>
			<img src="screenshot_2-17_16-38-9.png" alt="circle" style="width:50%"/>
			<figcaption>Circle of colors generated with triangles colored with the same method as the above image.</figcaption>
		</figure>
		
		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		For texture mapping, we have a screen space and a texture space. Each pixel in screen space corresponds to a point in texture space. 
		To texture the point, we could sample the closest pixel in texture space, but this can lead to aliasing artifacts.
		Instead, we can use bilinear interpolation to sample the 4 closest pixels in texture space and take a weighted average of them, in a way analogous to barycentric coordinates.
		We use linear interpolation in both the x and y direction to get a smooth result, which is why it is called bilinear.

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="screenshot_2-17_16-21-50.png" width="400px"/>
				  <figcaption>nearest sampling at 1 sample per pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-17_16-22-19.png" width="400px"/>
				  <figcaption>nearest sampling at 16 samples per pixel</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="screenshot_2-17_16-22-44.png" width="400px"/>
				  <figcaption>bilinear sampling at 1 sample per pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-17_16-22-55.png" width="400px"/>
				  <figcaption>bilinear sampling at 16 samples per pixel</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		The bilinear sampling adds smoothness to the texture, especially when the texture is very high frequency. The nearest sampling can look very blocky and pixelated, especially at low sample rates.
		The supersampling appears to add some local blurring to the texture, while the bilinear sampling adds some more global blurring. The supersampling is more effective at getting rid of aliasing artifacts, while the bilinear sampling is more effective at making the texture look smooth.


		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Level sampling is a way to ensure that textures look good from different distances. We compute pre-downsampled versions of the texture called mipmaps, which follow a geometric sequence of zoom.
		When we want to sample a texture, we compute the ratio of distance in screen space to distance in texture space using the Pythagorean theorem, and use this ratio to calculate the zoom level. Based on this, we can take the appropriate
		mipmap level. For example, an 8x zoom would correspond to a level 3 mipmap, which is downsampled by a factor of 8. 

		Pixel supersampling is helpful for blurring the image when edges cut through pixels, but it increases the time and memory usage proportionally. For example, 9x supersampling requires 9x the time and space. However, it is very powerful for antialiasing.
		With bilinear sampling, we don't need to do many extra calculations, just a few interpolations. We also don't need extra memory. However, it's not as strong as supersampling at getting rid of aliasing artifacts.
		With mipmaps, we spend 33% more memory to store the pre-downsampled textures, and we need to do some extra calculations to determine the appropriate level. The extra time it takes is minimal as well.
		However, it is very effective at getting rid of aliasing artifacts when textures are viewed from a distance, since they are already pre-blurred. 


		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>
